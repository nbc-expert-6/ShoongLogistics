## 📘 TDD 학습 과정 정리

해당 프로젝트에 TDD를 학습하여 적용하는 것이 목적이었으나 개발 진척도를 고려했을 때 완전한 적용은 힘들다고 판단하여 일부 내용만 적용하였습니다.<br>
<br>
실제 개발은 설계 -> 기능 구현 -> 테스트코드 작성 순으로 진행하였기 때문에 TDD를 적용했을 때의 이점보다는 TDD를 적용하지 않아 발생했던 문제를 통해 필요성을 체감할 수 있었습니다.
<br>
<br>
비록 TDD는 하지 못했지만 CI룰을 적용하여 테스트가 통과하지 않으면 pr단계에서 병합이 불가능하도록 프로젝트를 구성하여 모든 팀원이 테스트의 중요성을 느낄 수 있었습니다.

---

## 각 Step별 학습 내용과 느낀 점

### Step 1. 도메인테스트

__학습내용__
> 도메인 모델 중심 설계와 Given-When-Then 구조를 활용한 단위테스트 작성 방법에 대해 학습하고 모든 도메인 별로 도메인 계층에 있는 핵심 로직을 검증했습니다.

__느낀점__
> 테스트를 구현 이후에 작성하다 보니 설계 단계에서 놓쳤던 사항들에 대한 피드백이 늦게 와서 설계 변경시 작업 소요가 커짐을 느꼈습니다.
> <br>
> 그리고 테스트를 작성 하면서 구현된 로직을 살펴보니 해당 로직의 책임이 어디까지인지, 너무 크진 않은지 등을 판단할 수 있었습니다.

<br>

### Step 2. 서비스 레이어 테스트

__학습내용__
> Mock 객체(@Mock, @InjectMocks)를 활용해 외부 의존성을 격리한 테스트를 작성했습니다. 성공 케이스 뿐만 아니라 예외 케이스까지 검증해보면서 서비스 로직의 안정성을 확인했습니다.


__느낀점__
> Mocking을 통해 실제 DB를 호출하지 않고도 서비스 로직을 검증하는 단위 테스트를 수행할 수 있었는데, 이를 통해 계층별 책임과 역할을 분리하면 왜 테스트가 용이해지는지를 체감할 수 있었습니다.

<br>

### Step 3. 레포지토리 테스트

__학습내용__
> @DataJpaTest와 Docker Compose기반 Postgre를 활용해 레포지토리 단위테스트를 작성했습니다.


__느낀점__
> 실제 DB 환경에서 테스트를 실행해보니 설계와 쿼리의 정확성을 확인할 수 있었고, 테스트가 우리 프로젝트에 영향을 주지 않도록 DB 환경과 설정을 분리해야할 필요성을 체감하게 되었습니다.
>
<br>

### Step 4. 컨트롤러 및 통합 테스트

__학습내용__
> MockMvc를 활용한 Controller 단위 테스트와 RestAssured를 활용한 통합 테스트를 허브 도메인에서 진행했습니다.


__느낀점__
> 단위 테스트만으로는 전체 플로우의 오류를 잡기 어려우며 전체 시스템을 로드했을 때 테스트 환경과 실제 환경의 설정 차이로 인해 발생할 수 있는 문제를 사전에 점검할 수 있었습니다.

<br>

### Step 5. 리팩토링

__학습내용__
> @ParameterizedTest를 활용한 경계 테스트를 활용한 경계 테스트를 수행했습니다.

__느낀점__
> 개별 테스트로 경계 테스트를 수행했다가 이를 ParameterizedTest로 묶어내어 테스트 코드 구조를 개선해보면서 테스트 코드도 리팩토링 대상이 될 수 있음을 느꼈고 비즈니스 로직의 생산성, 가독성 만큼이나
> 테스트 코드의 생산성과 가독성도 중요하다는 점을 느꼈습니다.

---

## 회고

Red - Green - Refactoring이라는 사이클을 직접 경험하면서 장점을 체감하진 못했지만,
그렇지 않은 구조로 테스트 코드를 짜면서 TDD가 주는 이점을 간접적으로나마 체험해볼 수 있었습니다.
<br>
<br>
대부분 Mocking 정도만 알고있어서 경계 테스트를 하나로 묶어 테스트 코드를 리펙토링 한다던지, 테스트 환경을 위한 별도 DB나 설정의 구성이라던지 하는 부분들은
놓치고 있었는데 이번에 학습하면서 테스트코드에 대한 사고를 확장할 수 있었습니다.
<br>
<br>
모든 팀원이 방법론이나 테스트 코드 자체에 대한 이해도가 기존보다 높아져서 향후 진행할 프로젝트에서는
TDD 사이클까지 적용해볼 이론적 바탕이 마련되었다는 생각이 들었습니다.

